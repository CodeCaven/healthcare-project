<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>MonashTechTitans</title>
    <!-- MDB icon -->
    <link rel="icon" href="img/mdb-favicon.ico" type="image/x-icon" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/>
    <!-- Google Fonts Roboto -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&display=swap"/>
    <!-- MDB -->
	<link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.2.0/mdb.min.css" rel="stylesheet" />
    <!-- Bootstrap Datatables-->
	<link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.css" />
    

    <script src="https://d3js.org/d3.v6.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.5/turf.min.js"></script><!--turf for d2 winding order-->
    <!--<script src="https://d3js.org/d3.v4.min.js"></script> -->
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <script src="./javascripts/control.js"></script>
    <script type="text/javascript">
        
        // all data from the database
        let survey_data = <%-JSON.stringify(ejs_survey_list)%>;
        let states_geojson = JSON.parse(<%-JSON.stringify(ejs_states)%>);
        let phn_geojson = JSON.parse(<%-JSON.stringify(ejs_phn_geojson)%>);

        // global units
        let vhu;
        let vwu;

        // global vars
        let surveys = [];

        // DEV
        // get and check phn geojson data
        // get data in correct format for Obs. Chor (add id)
        // add div for svg
        // test plot one survey
        
        // DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {
            
           // log data
           console.log(survey_data);
           console.log(states_geojson);
           console.log(phn_geojson);

           // global units
           vhu = window.innerHeight/100;
           vwu = window.innerWidth/100;
           console.log("height and width window units");
           console.log(vhu);
           console.log(vwu);
            
          // get surveys
          let all_surveys = [];
          for(let i in survey_data){
            all_surveys.push(survey_data[i]["survey_desc"])
          }

          // set unique
          surveys = [...new Set(all_surveys)];
          

          // log survey data
          //for(let i in surveys){
            //console.log(surveys[i]);
            //console.log(get_survey(surveys[i], 2017));
          //}

          // initial choropleth
          //let map_div = document.getElementById('mapDiv');
          //let choropleth = Choropleth(get_survey(surveys[1], 2017), {features:phn_geojson, height:500, borders:state_features});
          //console.log(choropleth);
          //map_div.append(choropleth);

          draw_map("mapDiv", get_survey(surveys[1], 2017));

        }, false);

        // get individual survey data (only 5 have correct format, no errors)
        function get_survey(desc, year){
            let results = [];
            for(let i in survey_data){
                if(survey_data[i]["survey_desc"] == desc && survey_data[i]["year"] == year){
                    if(survey_data[i]["PHN_code"] !== "National"){
                        results.push(survey_data[i]);
                    }
                }
            }
            return results;
        }

        // Copyright 2021 Observable, Inc.
        // Released under the ISC license.
        // https://observablehq.com/@d3/choropleth
        function Choropleth(data, {
            id = d => d.PHN_code, // given d in data, returns the feature id
            value = d => d.per_cent, // given d in data, returns the quantitative value
            title, // given a feature f and possibly a datum d, returns the hover text
            format, // optional format specifier for the title
            scale = d3.scaleSequential, // type of color scale
            domain = [75,100], // [min, max] values; input of color scale
            range = d3.interpolateBlues, // output of color scale
            width = 640, // outer width, in pixels
            height, // outer height, in pixels
            projection = d3.geoMercator(),// a D3 projection; null for pre-projected geometry
            features, // a GeoJSON feature collection
            featureId = d => d.properties.FIRST_PHN_, // given a feature, returns its id
            borders, // a GeoJSON object for stroking borders
            outline =  null, // a GeoJSON object for the background
            unknown = "#ccc", // fill color for missing data
            fill = "white", // fill color for outline
            stroke = "white", // stroke color for borders
            strokeLinecap = "round", // stroke line cap for borders
            strokeLinejoin = "round", // stroke line join for borders
            strokeWidth = '20px', // stroke width for borders
            strokeOpacity = 1, // stroke opacity for borders
            } = {}) {
            // Compute values.
            const N = d3.map(data, id);
            const V = d3.map(data, value).map(d => d == null ? NaN : +d);
            const Im = new d3.InternMap(N.map((id, i) => [id, i]));
            const If = d3.map(features, featureId);

            // Compute default domains.
            if (domain === undefined) domain = d3.extent(V);

            // Construct scales.
            const color = scale(domain, range);
            if (color.unknown && unknown !== undefined) color.unknown(unknown);

            // Compute titles.
            if (title === undefined) {
                format = color.tickFormat(100, format);
                title = (f, i) => `${f.properties.name}\n${format(V[i])}`;
            } else if (title !== null) {
                const T = title;
                const O = d3.map(data, d => d);
                title = (f, i) => T(f, O[i]);
            }

            // Compute the default height. If an outline object is specified, scale the projection to fit
            // the width, and then compute the corresponding height.
            if (height === undefined) {
                if (outline === undefined) {
                height = 400;
                } else {
                const [[x0, y0], [x1, y1]] = d3.geoPath(projection.fitWidth(width, outline)).bounds(outline);
                const dy = Math.ceil(y1 - y0), l = Math.min(Math.ceil(x1 - x0), dy);
                projection.scale(projection.scale() * (l - 1) / l).precision(0.2);
                height = dy;
                }
            }

            // Construct a path generator.
            const path = d3.geoPath(projection);

            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "width: 100%; height: auto; height: intrinsic;");

            if (outline != null) svg.append("path")
                .attr("fill", fill)
                .attr("stroke", "currentColor")
                .attr("d", path(outline));

            svg.append("g")
                .selectAll("path")
                .data(features)
                .join("path")
                .attr("fill", (d, i) => color(V[Im.get(If[i])]))
                .attr("d", path)
                .append("title")
                .text((d, i) => title(d, Im.get(If[i])));

            if (borders != null) svg.append("path")
                .attr("pointer-events", "none")
                .attr("fill", "none")
                .attr("stroke", stroke)
                .attr("stroke-linecap", strokeLinecap)
                .attr("stroke-linejoin", strokeLinejoin)
                .attr("stroke-width", strokeWidth)
                .attr("stroke-opacity", strokeOpacity)
                .attr("d", path(borders));

            return Object.assign(svg.node(), {scales: {color}});
        }

        function draw_map(div, survey){
            // get width and height of plot area
            var plot_area = document.getElementById(div);
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // plot dimensions
            //console.log(plot_area.offsetHeight);
            //console.log(plot_area.offsetWidth);

            // set the dimensions and margins of the plot 
            var margin = {top: 0, 
                        right: 0, 
                        bottom: 0, 
                        left: 0};

            // chart width and height (leaving names from old code)
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // append the svg object to the plot area
            var svg = d3.select("#"+div)
            .append("svg")
                .attr("width", plot_width)
                .attr("height", plot_height)
                .attr("viewBox", [0, 0, plot_width, plot_height])
                .attr("style", "width: 100%; height: auto; height: intrinsic;")
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // create look up map
            var survey_map = new Map(Array.from(survey, d => [d.PHN_code, d]));
            //console.log(survey_map.get("PHN301")['per_cent']);

            // extent of values
            var all_values = d3.map(survey, d => d.per_cent);
            all_values = removeItemAll(all_values, 0); // remove 0s
            
            // color scale https://observablehq.com/@d3/color-schemes
            var color = d3.scaleSequential(d3.extent(all_values),d3.interpolateCividis);

            // unwind geojson using turf for d3        
            var phn_features = phn_geojson.features;
            var fixed_phn = phn_features.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            })

            var state_features = states_geojson.features;
            var fixed_state = state_features.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            })


            // Map and projection
            const projection = d3.geoMercator(); 
            projection.fitSize([width,height],{"type": "FeatureCollection","features":fixed_phn})
            const path = d3.geoPath().projection(projection);

            // phn areas
           svg
            .selectAll("path")
            .data(fixed_phn)
            .join("path")
            .attr("d", path)
            .attr("fill", function(d){
                //console.log(d.properties.FIRST_PHN_);
                console.log(survey_map.get(d.properties.FIRST_PHN_)['per_cent']);
                return color(survey_map.get(d.properties.FIRST_PHN_)['per_cent']);
            });     
            
            // state boundaries
            svg
            .datum(fixed_state)
            .attr("d", path)
            .attr("stroke", "white")
            .attr("stroke-width", "1")
            .attr("stroke-opacity", 0.5);
            
            
            
            

        }

        // remove items from array
        function removeItemAll(arr, value) {
            var i = 0;
            while (i < arr.length) {
                if (arr[i] === value) {
                arr.splice(i, 1);
                } else {
                ++i;
                }
            }
            return arr;
        }

        
    </script>
</head>